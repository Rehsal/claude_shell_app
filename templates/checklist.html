<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Checklist Copilot</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #fff;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Top bar */
        .top-bar {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 20px;
            background: #0f3460;
            border-bottom: 1px solid #374151;
            flex-shrink: 0;
        }

        .top-bar h1 {
            font-size: 1.1rem;
            color: #e94560;
            margin-right: 8px;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8rem;
        }

        .status-dot {
            width: 8px; height: 8px;
            border-radius: 50%;
            background: #f87171;
        }
        .status-dot.connected { background: #4ade80; }

        .conn-text { color: #94a3b8; }
        .conn-text.connected { color: #4ade80; }

        .spacer { flex: 1; }

        .runner-badge {
            font-size: 0.8rem;
            font-weight: 600;
            padding: 3px 10px;
            border-radius: 4px;
        }
        .runner-badge.idle { color: #94a3b8; background: #374151; }
        .runner-badge.running { color: #4ade80; background: rgba(74,222,128,0.15); }
        .runner-badge.paused { color: #fbbf24; background: rgba(251,191,36,0.15); }
        .runner-badge.waiting_confirm { color: #f59e0b; background: rgba(245,158,11,0.15); }
        .runner-badge.completed { color: #4ade80; background: rgba(74,222,128,0.2); }

        .btn {
            padding: 6px 14px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 500;
            color: white;
            transition: transform 0.1s, filter 0.1s;
            position: relative;
            text-align: center;
        }
        a.btn { display: inline-block; }
        .btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .btn-primary { background: #e94560; }
        .btn-primary:hover:not(:disabled) { background: #ff6b6b; }
        .btn-secondary { background: #374151; }
        .btn-secondary:hover:not(:disabled) { background: #4b5563; }
        .btn-success { background: #10b981; }
        .btn-success:hover:not(:disabled) { background: #34d399; }
        .btn-warning { background: #f59e0b; color: #000; }
        .btn-warning:hover:not(:disabled) { background: #fbbf24; }

        .btn:active:not(:disabled):not(.busy) {
            transform: scale(0.93);
            filter: brightness(0.75);
        }
        .btn.busy {
            color: transparent !important;
            pointer-events: none;
        }
        .btn.busy::after {
            content: '';
            position: absolute;
            width: 14px; height: 14px;
            top: 50%; left: 50%;
            margin: -7px 0 0 -7px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: #fff;
            border-radius: 50%;
            animation: btn-spin 0.6s linear infinite;
        }
        @keyframes btn-spin {
            to { transform: rotate(360deg); }
        }

        /* Load bar */
        .load-bar {
            display: flex;
            gap: 8px;
            padding: 10px 20px;
            background: #16213e;
            border-bottom: 1px solid #374151;
            flex-shrink: 0;
            align-items: center;
        }

        .load-bar input {
            flex: 1;
            padding: 6px 10px;
            background: #1a1a2e;
            border: 1px solid #374151;
            border-radius: 4px;
            color: #fff;
            font-size: 0.8rem;
        }
        .load-bar input:focus { outline: none; border-color: #e94560; }

        /* Checklist grid */
        .checklist-grid-container {
            padding: 12px 20px;
            background: #16213e;
            border-bottom: 1px solid #374151;
            flex-shrink: 0;
            display: none;
        }

        .checklist-grid-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .checklist-grid-header h3 {
            font-size: 0.75rem;
            font-weight: 700;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .checklist-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
            gap: 8px;
        }

        .checklist-btn {
            padding: 10px 12px;
            border: 2px solid #374151;
            border-radius: 6px;
            background: #1a1a2e;
            color: #e2e8f0;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 600;
            text-align: center;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            width: 100%;
        }

        .checklist-btn:hover {
            border-color: #e94560;
            background: #0f3460;
        }

        .checklist-btn:active:not(:disabled) {
            transform: scale(0.93);
            filter: brightness(0.75);
        }

        .checklist-btn.active {
            border-color: #e94560;
            background: #0f3460;
            box-shadow: 0 0 10px rgba(233, 69, 96, 0.3);
        }

        .checklist-btn.completed {
            border-color: #10b981;
            background: rgba(16, 185, 129, 0.1);
        }

        .checklist-btn.completed .check-icon {
            display: inline;
        }

        .checklist-btn .check-icon {
            display: none;
            color: #10b981;
            font-size: 1rem;
        }

        .checklist-btn .name {
            word-break: break-word;
        }

        /* Mode selector bar */
        .mode-bar {
            display: none;
            gap: 10px;
            padding: 10px 20px;
            background: #0f3460;
            border-bottom: 1px solid #374151;
            flex-shrink: 0;
            align-items: center;
        }

        .mode-bar label {
            font-size: 0.75rem;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .mode-btn {
            padding: 6px 16px;
            border: 1px solid #374151;
            border-radius: 4px;
            background: #1a1a2e;
            color: #e2e8f0;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 500;
            transition: all 0.2s;
        }

        .mode-btn:hover {
            border-color: #e94560;
        }

        .mode-btn.active {
            border-color: #e94560;
            background: #e94560;
            color: white;
        }

        /* PTT Button */
        .ptt-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #374151;
            background: #1a1a2e;
            color: #94a3b8;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            transition: all 0.2s;
        }

        .ptt-btn:hover {
            border-color: #e94560;
            color: #e94560;
        }

        .ptt-btn.listening {
            border-color: #10b981;
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.4); }
            50% { box-shadow: 0 0 0 10px rgba(16, 185, 129, 0); }
        }

        .ptt-feedback {
            font-size: 0.75rem;
            color: #94a3b8;
            font-style: italic;
        }

        /* Progress bar */
        .progress-strip {
            height: 4px;
            background: #374151;
            flex-shrink: 0;
        }
        .progress-strip .fill {
            height: 100%;
            background: #e94560;
            transition: width 0.3s;
            width: 0%;
        }

        /* Scrolling checklist items */
        .items-scroll {
            flex: 1;
            overflow-y: auto;
            padding: 12px 20px;
        }

        .section-header {
            font-size: 0.75rem;
            font-weight: 700;
            color: #e94560;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 12px 0 4px;
            border-bottom: 1px solid #374151;
            margin-bottom: 4px;
        }
        .section-header:first-child { padding-top: 0; }

        .item-row {
            display: flex;
            align-items: center;
            padding: 6px 10px;
            margin: 2px 0;
            border-radius: 5px;
            gap: 10px;
            font-size: 0.85rem;
        }

        .item-row.current {
            background: #0f3460;
            border-left: 3px solid #e94560;
        }
        .item-row.waiting {
            background: #3a2a0e;
            border-left: 3px solid #f59e0b;
        }
        .item-row.void {
            color: #64748b;
        }
        .item-row.done {
            color: #94a3b8;
        }

        .item-icon {
            width: 20px; height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            font-size: 0.65rem;
            font-weight: 700;
        }
        .icon-check { background: #10b981; color: #fff; }
        .icon-void { background: #374151; color: #64748b; }
        .icon-skip { background: #64748b; color: #fff; }
        .icon-current { background: #e94560; color: #fff; }
        .icon-waiting { background: #f59e0b; color: #000; }
        .icon-pending { background: #374151; color: #94a3b8; }
        .icon-error { background: #f87171; color: #fff; }
        .icon-confirm { background: #4ade80; color: #000; }
        .icon-remark { background: transparent; color: #94a3b8; }

        .item-label { flex: 1; }
        .item-label .checked { color: #4ade80; margin-left: 6px; }
        .item-label .checked.dim { color: #64748b; }

        /* Bottom bar */
        .bottom-bar {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            background: #16213e;
            border-top: 1px solid #374151;
            flex-shrink: 0;
        }

        .bottom-bar .confirm-msg {
            flex: 1;
            font-size: 0.85rem;
            color: #fbbf24;
        }

        .progress-text {
            font-size: 0.75rem;
            color: #64748b;
        }

        /* Log panel with resizable handle */
        .log-container {
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            min-height: 100px;
            max-height: 80vh;
        }

        .log-handle {
            height: 8px;
            background: #374151;
            cursor: ns-resize;
            display: flex;
            align-items: center;
            justify-content: center;
            border-top: 1px solid #4b5563;
        }

        .log-handle::after {
            content: '';
            width: 40px;
            height: 3px;
            background: #64748b;
            border-radius: 2px;
        }

        .log-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 4px 20px;
            background: #111827;
            border-bottom: 1px solid #374151;
        }

        .log-header span {
            font-size: 0.7rem;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .log-panel {
            flex: 1;
            overflow-y: auto;
            background: #111827;
            font-family: monospace;
            font-size: 0.75rem;
            color: #94a3b8;
            padding: 8px 20px;
        }
        .log-panel .entry { padding: 1px 0; white-space: pre-wrap; }
        .log-panel .entry.cmd { color: #4ade80; }
        .log-panel .entry.write { color: #60a5fa; }
        .log-panel .entry.skip-write { color: #f59e0b; }
        .log-panel .entry.error { color: #f87171; }
        .log-panel .entry.done { color: #4ade80; font-weight: 600; }
        .log-panel .entry.exec { color: #e2e8f0; }
        .log-panel .entry.needs { color: #f59e0b; font-weight: 600; }
        .log-panel .entry.zibo { color: #a78bfa; }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #64748b;
        }
        .empty-state h3 { color: #94a3b8; margin-bottom: 8px; }

        /* Checkbox styling */
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 4px;
            color: #9ca3af;
            font-size: 0.78rem;
            cursor: pointer;
            white-space: nowrap;
        }

        /* Annunciator Alert */
        .annunciator-alert {
            position: fixed;
            top: 80px;
            right: 20px;
            background: linear-gradient(135deg, #7f1d1d 0%, #991b1b 100%);
            border: 2px solid #fca5a5;
            border-radius: 8px;
            padding: 16px 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), 0 0 20px rgba(248, 113, 113, 0.3);
            z-index: 1000;
            display: none;
            animation: alertPulse 0.5s ease-out;
            max-width: 350px;
        }

        .annunciator-alert.show {
            display: block;
        }

        @keyframes alertPulse {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); opacity: 1; }
        }

        .annunciator-alert .alert-title {
            font-size: 0.7rem;
            font-weight: 600;
            color: #fca5a5;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 4px;
        }

        .annunciator-alert .alert-message {
            font-size: 1.1rem;
            font-weight: 700;
            color: #fff;
        }

        .annunciator-alert .alert-dismiss {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            color: #fca5a5;
            cursor: pointer;
            font-size: 1.2rem;
            line-height: 1;
            padding: 4px;
        }

        .annunciator-alert .alert-dismiss:hover {
            color: #fff;
        }

        /* Annunciator status indicator */
        .annunciator-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            color: #6b7280;
        }

        .annunciator-status.active {
            color: #4ade80;
        }

        .annunciator-status.disabled {
            color: #f87171;
        }

        .annunciator-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #6b7280;
        }

        .annunciator-status.active .annunciator-dot {
            background: #4ade80;
            box-shadow: 0 0 6px #4ade80;
        }

        .annunciator-status.disabled .annunciator-dot {
            background: #f87171;
        }

        /* ANN Toggle Switch */
        .ann-toggle {
            position: relative;
            width: 36px;
            height: 18px;
            background: #374151;
            border-radius: 9px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .ann-toggle.on {
            background: #10b981;
        }

        .ann-toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            background: white;
            border-radius: 50%;
            transition: transform 0.2s;
        }

        .ann-toggle.on::after {
            transform: translateX(18px);
        }
    </style>
</head>
<body>
    <!-- Top bar -->
    <div class="top-bar">
        <h1>Checklist Copilot</h1>
        <div class="connection-status">
            <div class="status-dot" id="statusDot"></div>
            <span class="conn-text" id="connText">Checking...</span>
        </div>
        <div class="spacer"></div>
        <div class="annunciator-status" id="annunciatorStatus" title="Annunciator Monitor">
            <div class="annunciator-dot"></div>
            <span>ANN</span>
            <div class="ann-toggle on" id="annToggle" onclick="toggleAnnunciator()" title="Toggle Annunciators On/Off"></div>
        </div>
        <span class="runner-badge idle" id="runnerBadge">IDLE</span>
        <span id="serverVersion" style="color:#6b7280;font-size:0.65rem;margin-left:8px;"></span>
        <button class="btn btn-success" id="btnInitChecklist" onclick="initializeChecklist()">Initialize</button>
        <button class="btn btn-primary" id="btnRestart" onclick="restartChecklist()" disabled>Restart</button>
    </div>

    <!-- Load bar -->
    <div class="load-bar" id="loadBar">
        <input type="text" id="clistPath" placeholder="Path to checklist file (.xlsx, .csv, or .txt — blank to auto-detect)">
        <button class="btn btn-primary" onclick="loadChecklist()">Load</button>
        <button class="btn btn-secondary" onclick="releaseChecklist()">Release</button>
        <label class="checkbox-label">
            <input type="checkbox" id="chkAutoContinue" checked onchange="toggleAutoContinue(this.checked)"> Auto-Continue
        </label>
        <label class="checkbox-label">
            <input type="checkbox" id="chkSpeech" checked onchange="toggleSpeech(this.checked)"> Speech
        </label>
    </div>

    <!-- Checklist button grid (shown after load) -->
    <div class="checklist-grid-container" id="checklistGridContainer">
        <div class="checklist-grid-header">
            <h3>Checklists</h3>
            <button class="btn btn-secondary" onclick="clearAllCompleted()">Clear All</button>
        </div>
        <div class="checklist-grid" id="checklistGrid"></div>
    </div>

    <!-- Mode selector bar -->
    <div class="mode-bar" id="modeBar">
        <label>MODE:</label>
        <button class="mode-btn" id="btnModeStep" onclick="setMode('step')">Step</button>
        <button class="mode-btn active" id="btnModeRun" onclick="setMode('run')">Run</button>
        <button class="mode-btn" id="btnModeSeries" onclick="setMode('series')">Run Series</button>
        <div class="spacer"></div>
        <button class="ptt-btn" id="pttBtn" title="Hold to speak">
            <span>&#127908;</span>
        </button>
        <span class="ptt-feedback" id="pttFeedback"></span>
    </div>

    <!-- Progress -->
    <div class="progress-strip"><div class="fill" id="progressFill"></div></div>

    <!-- Scrolling item list -->
    <div class="items-scroll" id="itemsScroll">
        <div class="empty-state">
            <h3>No Checklist Loaded</h3>
            <p>Click Load to parse the checklist file, then select a checklist to begin</p>
        </div>
    </div>

    <!-- Bottom bar -->
    <div class="bottom-bar">
        <span class="confirm-msg" id="confirmMsg" style="display:none;"></span>
        <button class="btn btn-success" id="btnConfirm" onclick="confirmItem()" style="display:none;">Confirm</button>
        <button class="btn btn-secondary" id="btnSkip" onclick="skipItem()" disabled>Skip</button>
        <button class="btn btn-warning" id="btnPause" onclick="togglePause()" disabled>Pause</button>
        <div class="spacer"></div>
        <span class="progress-text" id="progressText"></span>
    </div>

    <!-- Activity log with resize handle -->
    <div class="log-container" id="logContainer">
        <div class="log-handle" id="logHandle"></div>
        <div class="log-header">
            <span>Activity Log</span>
            <button class="btn btn-secondary" style="padding:2px 8px;font-size:0.7rem;" onclick="clearLog()">Clear</button>
        </div>
        <div class="log-panel" id="logPanel"></div>
    </div>

    <!-- Annunciator floating alert -->
    <div class="annunciator-alert" id="annunciatorAlert">
        <button class="alert-dismiss" onclick="dismissAnnunciatorAlert()">&times;</button>
        <div class="alert-title">FLIGHT CONTROL</div>
        <div class="alert-message" id="annunciatorMessage"></div>
    </div>

    <!-- Hidden audio element for alert tone -->
    <audio id="alertTone" preload="auto">
        <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdH2Onp+ZjXp0eISPlZSGb2Bka36KkYt+cmpvfIiOjIJ1bXB5hYuJf3RvcHqEiod+dXFxeoOHhX1zcHJ5gYWDfXVycnl/goF9d3NzeH6Bf3t1c3R4fX9+enZzdHZ7fXx6d3R1dnh7enl3dXV2eHl5eHd2dnd4eHh4d3Z2d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3" type="audio/wav">
    </audio>

    <script>
        let connected = false;
        let loaded = false;
        let lastHistoryLen = 0;
        let pollTimer = null;
        let paused = false;
        let currentMode = 'run';
        let selectedChecklist = null;
        let allChecklists = [];
        let completedChecklists = new Set();

        // Annunciator monitoring state
        let annunciatorMonitorActive = false;
        let annunciatorEnabled = true;  // Master switch state
        let annunciatorAlertTimeout = null;

        let pageVersion = document.querySelector('meta[name="server-version"]')?.content || '';

        // Log panel resizing
        let logHeight = parseInt(localStorage.getItem('logPanelHeight')) || 160;
        const logContainer = document.getElementById('logContainer');
        const logHandle = document.getElementById('logHandle');
        logContainer.style.height = logHeight + 'px';

        let isResizing = false;
        logHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
        });

        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;
            const containerRect = logContainer.parentElement.getBoundingClientRect();
            const newHeight = containerRect.bottom - e.clientY;
            if (newHeight >= 100 && newHeight <= window.innerHeight * 0.8) {
                logHeight = newHeight;
                logContainer.style.height = newHeight + 'px';
            }
        });

        document.addEventListener('mouseup', () => {
            if (isResizing) {
                isResizing = false;
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                localStorage.setItem('logPanelHeight', logHeight);
            }
        });

        // Voice recognition
        let recognition = null;
        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-US';

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript.toLowerCase().trim();
                document.getElementById('pttFeedback').textContent = `"${transcript}"`;
                handleVoiceCommand(transcript);
            };

            recognition.onerror = (event) => {
                console.log('Speech error:', event.error);
                document.getElementById('pttFeedback').textContent = 'Error: ' + event.error;
            };

            recognition.onend = () => {
                document.getElementById('pttBtn').classList.remove('listening');
            };
        }

        const pttBtn = document.getElementById('pttBtn');
        if (recognition) {
            pttBtn.addEventListener('mousedown', () => {
                pttBtn.classList.add('listening');
                document.getElementById('pttFeedback').textContent = 'Listening...';
                recognition.start();
            });
            pttBtn.addEventListener('mouseup', () => {
                recognition.stop();
            });
            pttBtn.addEventListener('mouseleave', () => {
                if (pttBtn.classList.contains('listening')) {
                    recognition.stop();
                }
            });
        } else {
            pttBtn.style.display = 'none';
        }

        function handleVoiceCommand(transcript) {
            // Voice commands must include "procedure" to be unique from other commands
            // Patterns: "preflight procedure", "start one procedure", "run series procedure"
            if (!transcript.includes('procedure')) {
                document.getElementById('pttFeedback').textContent = 'Say "[checklist] procedure"';
                return;
            }

            // Extract the checklist name by removing "procedure" and mode words
            let checklistName = transcript
                .replace('procedure', '')
                .replace('run series', '')
                .replace('step', '')
                .replace('run', '')
                .trim();

            // Check for mode commands
            if (transcript.includes('run series')) {
                setMode('series');
            } else if (transcript.includes('step')) {
                setMode('step');
            } else if (transcript.includes('run')) {
                setMode('run');
            }

            // Find matching checklist
            if (checklistName) {
                const match = findChecklistByVoice(checklistName);
                if (match) {
                    selectAndStartChecklist(match);
                } else {
                    document.getElementById('pttFeedback').textContent = `No match for "${checklistName}"`;
                }
            }
        }

        function findChecklistByVoice(spoken) {
            // Fuzzy match: find checklist whose name contains all spoken words
            const spokenWords = spoken.toLowerCase().split(/\s+/).filter(w => w.length > 1);
            for (const cl of allChecklists) {
                const clWords = cl.toLowerCase().replace(/[_-]/g, ' ').split(/\s+/);
                const allMatch = spokenWords.every(sw =>
                    clWords.some(cw => cw.includes(sw) || sw.includes(cw))
                );
                if (allMatch) return cl;
            }
            // Try partial match
            for (const cl of allChecklists) {
                if (cl.toLowerCase().includes(spokenWords[0])) return cl;
            }
            return null;
        }

        document.addEventListener('DOMContentLoaded', async () => {
            document.getElementById('serverVersion').textContent = 'v' + pageVersion;
            await checkConnection();
            setInterval(checkConnection, 10000);
            // Check for server restart — auto-refresh if version changes
            setInterval(async () => {
                try {
                    const r = await fetch('/api/version');
                    const d = await r.json();
                    if (pageVersion && d.version !== pageVersion) {
                        console.log('Server restarted, refreshing...');
                        location.reload();
                    }
                } catch {}
            }, 5000);
        });

        // ---- Connection ----
        async function checkConnection() {
            try {
                const r = await fetch('/api/extplane/status');
                const d = await r.json();
                const was = connected;
                connected = d.connected;
                updateConn();
                if (!connected && !was) {
                    await fetch('/api/extplane/connect', { method: 'POST' });
                    setTimeout(checkConnection, 1000);
                }
            } catch {
                connected = false;
                updateConn();
            }
        }

        function updateConn() {
            document.getElementById('statusDot').className = 'status-dot' + (connected ? ' connected' : '');
            const t = document.getElementById('connText');
            t.className = 'conn-text' + (connected ? ' connected' : '');
            t.textContent = connected ? 'Connected' : 'Disconnected';
        }

        // ---- Load ----
        async function loadChecklist() {
            const loadBtn = document.querySelector('.load-bar .btn-primary');
            if (loadBtn) loadBtn.classList.add('busy');
            const path = document.getElementById('clistPath').value;
            const fd = new FormData();
            fd.append('path', path);
            try {
                const r = await fetch('/api/checklist/load', { method: 'POST', body: fd });
                if (!r.ok) { const e = await r.json(); alert(e.detail || 'Failed'); return; }
                const d = await r.json();
                loaded = true;
                allChecklists = d.checklists;
                completedChecklists.clear();

                // Show checklist grid
                renderChecklistGrid();
                document.getElementById('checklistGridContainer').style.display = 'block';
                document.getElementById('modeBar').style.display = 'flex';

                document.getElementById('itemsScroll').innerHTML =
                    `<div class="empty-state"><h3>Loaded ${d.checklists.length} checklists</h3><p>${d.summary || 'Select a checklist to begin'}</p></div>`;

                startPolling();
            } catch (e) {
                alert('Error: ' + e.message);
            } finally {
                if (loadBtn) loadBtn.classList.remove('busy');
            }
        }

        function renderChecklistGrid() {
            const grid = document.getElementById('checklistGrid');
            grid.innerHTML = '';

            allChecklists.forEach(name => {
                const btn = document.createElement('button');
                btn.className = 'checklist-btn';
                if (completedChecklists.has(name)) btn.classList.add('completed');
                if (selectedChecklist === name) btn.classList.add('active');

                btn.innerHTML = `
                    <span class="check-icon">&#10003;</span>
                    <span class="name">${escHtml(name)}</span>
                `;
                btn.onclick = () => selectAndStartChecklist(name);
                grid.appendChild(btn);
            });
        }

        function selectAndStartChecklist(name) {
            selectedChecklist = name;
            renderChecklistGrid();

            // Start based on mode
            if (currentMode === 'step') {
                startChecklistStep(name);
            } else if (currentMode === 'series') {
                startChecklistSeries(name);
            } else {
                startChecklistRun(name);
            }
        }

        // ---- Mode selection ----
        function setMode(mode) {
            currentMode = mode;
            document.getElementById('btnModeStep').classList.toggle('active', mode === 'step');
            document.getElementById('btnModeRun').classList.toggle('active', mode === 'run');
            document.getElementById('btnModeSeries').classList.toggle('active', mode === 'series');
        }

        // ---- Start / Restart ----
        async function startChecklistRun(name) {
            const fd = new FormData();
            fd.append('name', name);
            fd.append('auto_run', 'true');
            await fetch('/api/checklist/start', { method: 'POST', body: fd });

            lastHistoryLen = 0;
            document.getElementById('itemsScroll').innerHTML = '';
            document.getElementById('btnRestart').disabled = false;
            startPolling();
        }

        async function startChecklistStep(name) {
            const fd = new FormData();
            fd.append('name', name);
            fd.append('auto_run', 'false');
            await fetch('/api/checklist/start', { method: 'POST', body: fd });

            lastHistoryLen = 0;
            document.getElementById('itemsScroll').innerHTML = '';
            document.getElementById('btnRestart').disabled = false;
            startPolling();
        }

        async function startChecklistSeries(name) {
            const fd = new FormData();
            fd.append('start', name);
            await fetch('/api/checklist/run_series', { method: 'POST', body: fd });

            lastHistoryLen = 0;
            document.getElementById('itemsScroll').innerHTML = '';
            document.getElementById('btnRestart').disabled = false;
            startPolling();
        }

        async function restartChecklist() {
            lastHistoryLen = 0;
            document.getElementById('itemsScroll').innerHTML = '';
            await fetch('/api/checklist/restart', { method: 'POST' });
            startPolling();
        }

        // ---- Polling ----
        function startPolling() {
            if (pollTimer) return;
            pollTimer = setInterval(poll, 500);
            poll();
        }

        async function poll() {
            try {
                const r = await fetch('/api/checklist/status');
                const s = await r.json();
                renderStatus(s);
            } catch {}
        }

        // ---- Render ----
        function renderStatus(s) {
            // Update completed checklists from server
            if (s.completed_checklists) {
                completedChecklists = new Set(s.completed_checklists);
            }
            if (s.all_checklists && s.all_checklists.length > 0) {
                allChecklists = s.all_checklists;
            }
            if (allChecklists.length > 0 && loaded) {
                renderChecklistGrid();
            }

            // Badge
            const badge = document.getElementById('runnerBadge');
            badge.textContent = s.state.toUpperCase().replace('_', ' ');
            badge.className = 'runner-badge ' + s.state;

            // Progress
            document.getElementById('progressFill').style.width = s.progress + '%';
            document.getElementById('progressText').textContent =
                s.progress_total > 0 ? `${s.progress_total} items processed` : '';

            // State-dependent buttons
            const isRunning = s.state === 'running';
            const isWaiting = s.state === 'waiting_confirm';
            const isPaused = s.state === 'paused';
            paused = isPaused;

            document.getElementById('btnPause').disabled = !isRunning && !isWaiting && !isPaused;
            document.getElementById('btnPause').textContent = isPaused ? 'Resume' : 'Pause';
            document.getElementById('btnSkip').disabled = !(isRunning || isWaiting || isPaused);

            // Sync settings checkboxes
            if (s.auto_continue !== undefined)
                document.getElementById('chkAutoContinue').checked = s.auto_continue;
            if (s.speech_enabled !== undefined)
                document.getElementById('chkSpeech').checked = s.speech_enabled;

            // Confirm UI — always show confirm/skip when running or waiting
            const confirmMsg = document.getElementById('confirmMsg');
            const confirmBtn = document.getElementById('btnConfirm');
            if (s.current_item && (isWaiting || isRunning)) {
                confirmMsg.style.display = '';
                confirmMsg.textContent = `${s.current_item.label} — ${s.current_item.checked_text}`;
                confirmBtn.style.display = '';
            } else {
                confirmMsg.style.display = 'none';
                confirmBtn.style.display = 'none';
            }

            // Render history + current item
            renderItems(s);

            // Log — always visible, color-coded
            const lp = document.getElementById('logPanel');
            if (s.log && s.log.length) {
                lp.innerHTML = s.log.map(l => {
                    let cls = '';
                    if (l.startsWith('Command:')) cls = 'cmd';
                    else if (l.includes('Write:')) cls = 'write';
                    else if (l.includes('Skip write')) cls = 'skip-write';
                    else if (l.includes('Zibo')) cls = 'zibo';
                    else if (l.startsWith('Done')) cls = 'done';
                    else if (l.startsWith('Already OK')) cls = 'done';
                    else if (l.startsWith('Executing:')) cls = 'exec';
                    else if (l.startsWith('Needs attention')) cls = 'needs';
                    else if (l.includes('Error') || l.includes('failed')) cls = 'error';
                    return `<div class="entry ${cls}">${escHtml(l)}</div>`;
                }).join('');
                const nearBottom = lp.scrollHeight - lp.scrollTop - lp.clientHeight < 80;
                if (nearBottom) lp.scrollTop = lp.scrollHeight;
            }

            // Update active checklist in grid
            if (s.current_checklist_name) {
                selectedChecklist = s.current_checklist_name;
            }
        }

        function renderItems(s) {
            const container = document.getElementById('itemsScroll');
            const history = s.history || [];

            // Incremental: only add new items
            if (history.length > lastHistoryLen) {
                for (let i = lastHistoryLen; i < history.length; i++) {
                    const h = history[i];
                    // Section header if changed
                    if (i === 0 || history[i].section !== history[i-1].section) {
                        const hdr = document.createElement('div');
                        hdr.className = 'section-header';
                        hdr.textContent = h.section || 'CHECKLIST';
                        container.appendChild(hdr);
                    }
                    container.appendChild(makeHistoryRow(h));
                    if (h.speak) { console.log('TTS:', h.speak); speak(h.speak); }
                }
                lastHistoryLen = history.length;
            }

            // Remove old current-item marker
            const oldCur = container.querySelector('.item-row.current, .item-row.waiting');
            if (oldCur && oldCur.id === '__current') oldCur.remove();

            // Add current item
            if (s.current_item && s.state !== 'completed' && s.state !== 'idle') {
                const row = document.createElement('div');
                row.className = 'item-row ' + (s.state === 'waiting_confirm' ? 'waiting' : 'current');
                row.id = '__current';
                const isWait = s.state === 'waiting_confirm';
                const iconCls = isWait ? 'icon-waiting' : 'icon-current';
                const iconChar = isWait ? '?' : '&#9654;';
                const ci = s.current_item;
                row.innerHTML = `
                    <div class="item-icon ${iconCls}">${iconChar}</div>
                    <div class="item-label">
                        ${escHtml(ci.label || ci.continue_target || '')}
                        ${ci.checked_text ? `<span class="checked">${escHtml(ci.checked_text)}</span>` : ''}
                    </div>`;
                container.appendChild(row);
                row.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }

            // Completed marker
            if (s.state === 'completed') {
                if (!container.querySelector('.completed-marker')) {
                    const done = document.createElement('div');
                    done.className = 'item-row completed-marker';
                    done.style.cssText = 'background:rgba(74,222,128,0.1);border-left:3px solid #4ade80;margin-top:8px;';
                    done.innerHTML = `<div class="item-icon icon-check">&#10003;</div>
                        <div class="item-label" style="color:#4ade80;font-weight:600;">Checklist Complete</div>`;
                    container.appendChild(done);
                    done.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }
        }

        function makeHistoryRow(h) {
            const row = document.createElement('div');
            const isVoid = h.type === 'sw_itemvoid';
            const isRemark = h.type === 'sw_remark';
            const isContinue = h.type === 'sw_continue';
            const isSkipped = h.status === 'skipped';
            const isSatisfied = h.status === 'satisfied' || h.status === 'confirmed';

            let cls = 'item-row';
            if (isVoid || isRemark) cls += ' void';
            else if (isSatisfied) cls += ' done';
            else if (isSkipped) cls += ' done';

            row.className = cls;

            let iconCls, iconChar;
            if (isSatisfied) { iconCls = 'icon-check'; iconChar = '&#10003;'; }
            else if (h.status === 'confirmed') { iconCls = 'icon-confirm'; iconChar = '&#10003;'; }
            else if (isVoid) { iconCls = 'icon-void'; iconChar = '&mdash;'; }
            else if (isRemark) { iconCls = 'icon-remark'; iconChar = '&#8505;'; }
            else if (isContinue) { iconCls = 'icon-pending'; iconChar = '&#187;'; }
            else if (isSkipped) { iconCls = 'icon-skip'; iconChar = '&#8212;'; }
            else if (h.status === 'timeout') { iconCls = 'icon-skip'; iconChar = '&#8987;'; }
            else if (h.status === 'error') { iconCls = 'icon-error'; iconChar = '!'; }
            else { iconCls = 'icon-pending'; iconChar = '?'; }

            const label = h.label || h.continue_target || '';
            const checked = h.checked_text || '';
            const dimChecked = isVoid || isRemark;

            row.innerHTML = `
                <div class="item-icon ${iconCls}">${iconChar}</div>
                <div class="item-label">
                    ${escHtml(label)}
                    ${checked ? `<span class="checked${dimChecked ? ' dim' : ''}">${escHtml(checked)}</span>` : ''}
                </div>`;
            return row;
        }

        // ---- Actions ----
        async function confirmItem() {
            await fetch('/api/checklist/confirm', { method: 'POST' });
        }

        async function skipItem() {
            await fetch('/api/checklist/skip', { method: 'POST' });
        }

        async function clearAllCompleted() {
            await fetch('/api/checklist/clear_completed', { method: 'POST' });
            completedChecklists.clear();
            renderChecklistGrid();
        }

        function clearLog() {
            document.getElementById('logPanel').innerHTML = '';
        }

        let speechQueue = [];
        let isSpeaking = false;

        function speak(text) {
            if (!window.speechSynthesis) {
                fetch('/api/checklist/speech_done', { method: 'POST' });
                return;
            }
            speechQueue.push(text);
            if (!isSpeaking) speakNext();
        }

        function speakNext() {
            if (speechQueue.length === 0) {
                isSpeaking = false;
                return;
            }
            isSpeaking = true;
            const text = speechQueue.shift();
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = 1.1;
            utterance.pitch = 1.0;
            utterance.volume = 1.0;
            utterance.onend = () => {
                fetch('/api/checklist/speech_done', { method: 'POST' });
                speakNext();
            };
            utterance.onerror = () => {
                fetch('/api/checklist/speech_done', { method: 'POST' });
                speakNext();
            };
            speechSynthesis.speak(utterance);
        }

        async function toggleSpeech(enabled) {
            const form = new FormData();
            if (enabled) form.append('enabled', 'true');
            await fetch('/api/checklist/speech', { method: 'POST', body: form });
        }

        async function toggleAutoContinue(enabled) {
            const form = new FormData();
            if (enabled) form.append('enabled', 'true');
            await fetch('/api/checklist/auto_continue', { method: 'POST', body: form });
        }

        async function initializeChecklist() {
            const btn = document.getElementById('btnInitChecklist');
            btn.disabled = true;
            btn.textContent = 'Initializing...';
            try {
                // 1. Full teardown
                await fetch('/api/checklist/release', { method: 'POST' });

                // 2. Reset JS state
                loaded = false;
                lastHistoryLen = 0;
                selectedChecklist = null;
                allChecklists = [];
                completedChecklists.clear();
                speechQueue = [];
                isSpeaking = false;
                if (window.speechSynthesis) speechSynthesis.cancel();

                // 3. Stop polling
                if (pollTimer) { clearInterval(pollTimer); pollTimer = null; }

                // 4. Clear DOM
                document.getElementById('checklistGrid').innerHTML = '';
                document.getElementById('checklistGridContainer').style.display = 'none';
                document.getElementById('modeBar').style.display = 'none';
                document.getElementById('itemsScroll').innerHTML = '';
                document.getElementById('progressFill').style.width = '0%';
                document.getElementById('progressText').textContent = '';
                document.getElementById('confirmMsg').style.display = 'none';
                document.getElementById('btnConfirm').style.display = 'none';
                document.getElementById('logPanel').innerHTML = '';
                document.getElementById('btnRestart').disabled = true;
                document.getElementById('runnerBadge').textContent = 'IDLE';
                document.getElementById('runnerBadge').className = 'runner-badge idle';
                document.getElementById('btnSkip').disabled = true;
                document.getElementById('btnPause').disabled = true;

                // 5. Load checklist (auto-detect if path empty)
                const path = document.getElementById('clistPath').value;
                const fd = new FormData();
                fd.append('path', path);
                const r = await fetch('/api/checklist/load', { method: 'POST', body: fd });
                if (!r.ok) { const e = await r.json(); throw new Error(e.detail || 'Load failed'); }
                const d = await r.json();

                // 6. Populate state and UI
                loaded = true;
                allChecklists = d.checklists;
                renderChecklistGrid();
                document.getElementById('checklistGridContainer').style.display = 'block';
                document.getElementById('modeBar').style.display = 'flex';
                document.getElementById('itemsScroll').innerHTML =
                    `<div class="empty-state"><h3>Loaded ${d.checklists.length} checklists</h3><p>${d.summary || 'Select a checklist to begin'}</p></div>`;

                // 7. Restart polling
                startPolling();
            } catch (e) {
                alert('Initialize error: ' + e.message);
            } finally {
                btn.disabled = false;
                btn.textContent = 'Initialize';
            }
        }

        async function releaseChecklist() {
            await fetch('/api/checklist/release', { method: 'POST' });
            loaded = false;
            lastHistoryLen = 0;
            selectedChecklist = null;
            allChecklists = [];
            completedChecklists.clear();

            document.getElementById('btnRestart').disabled = true;
            document.getElementById('checklistGridContainer').style.display = 'none';
            document.getElementById('modeBar').style.display = 'none';
            document.getElementById('itemsScroll').innerHTML =
                '<div class="empty-state"><h3>Checklist Released</h3><p>Edit your file, then click Load to reload</p></div>';
        }

        async function togglePause() {
            if (paused) {
                await fetch('/api/checklist/resume', { method: 'POST' });
            } else {
                await fetch('/api/checklist/pause', { method: 'POST' });
            }
        }

        function escHtml(s) {
            const d = document.createElement('div');
            d.textContent = s;
            return d.innerHTML;
        }

        // ---- Annunciator Monitoring ----
        async function initAnnunciators() {
            try {
                // Load annunciators from default file
                const form = new FormData();
                const loadRes = await fetch('/api/annunciator/load', { method: 'POST', body: form });
                const loadData = await loadRes.json();
                if (loadData.status === 'ok' && loadData.count > 0) {
                    console.log(`Loaded ${loadData.count} annunciators from ${loadData.path}`);
                    // Start monitoring if ExtPlane is connected
                    if (connected) {
                        await startAnnunciatorMonitor();
                    }
                }
            } catch (e) {
                console.log('Annunciator init:', e.message);
            }
        }

        async function startAnnunciatorMonitor() {
            try {
                const res = await fetch('/api/annunciator/start', { method: 'POST' });
                const data = await res.json();
                if (data.status === 'ok') {
                    annunciatorMonitorActive = true;
                    updateAnnunciatorStatus();
                    console.log('Annunciator monitor started');
                }
            } catch (e) {
                console.log('Failed to start annunciator monitor:', e.message);
            }
        }

        async function checkAnnunciatorStatus() {
            try {
                const res = await fetch('/api/annunciator/status');
                const data = await res.json();
                annunciatorMonitorActive = data.running;
                if (data.enabled !== undefined) {
                    annunciatorEnabled = data.enabled;
                }
                updateAnnunciatorStatus();

                // If connected but not running, try to start
                if (connected && !annunciatorMonitorActive && data.annunciator_count > 0) {
                    await startAnnunciatorMonitor();
                }
            } catch (e) {
                // Don't change status on network errors - keep last known state
                console.log('Annunciator status check failed:', e);
            }
        }

        function updateAnnunciatorStatus() {
            const el = document.getElementById('annunciatorStatus');
            const toggle = document.getElementById('annToggle');

            // Update toggle state
            if (annunciatorEnabled) {
                toggle.classList.add('on');
            } else {
                toggle.classList.remove('on');
            }

            // Update status indicator
            el.classList.remove('active', 'disabled');
            if (!annunciatorEnabled) {
                el.classList.add('disabled');
                el.title = 'Annunciator Monitor: OFF';
            } else if (annunciatorMonitorActive) {
                el.classList.add('active');
                el.title = 'Annunciator Monitor: Active';
            } else {
                el.title = 'Annunciator Monitor: Inactive';
            }
        }

        async function toggleAnnunciator() {
            const newState = !annunciatorEnabled;
            console.log('Toggling annunciator to:', newState);

            const form = new FormData();
            form.append('enabled', newState ? 'true' : 'false');

            try {
                const res = await fetch('/api/annunciator/toggle', { method: 'POST', body: form });
                const data = await res.json();
                console.log('Toggle response:', data);
                if (data.status === 'ok') {
                    annunciatorEnabled = data.enabled;
                    updateAnnunciatorStatus();
                    console.log('Annunciator switch:', annunciatorEnabled ? 'ON' : 'OFF');
                } else {
                    console.log('Toggle failed:', data);
                }
            } catch (e) {
                console.log('Failed to toggle annunciator:', e);
            }
        }

        async function pollAnnunciatorAlert() {
            // Always poll - don't depend on status variable
            try {
                const res = await fetch('/api/annunciator/alert');
                const data = await res.json();
                if (data.alert) {
                    console.log('Alert received:', data.alert);
                    showAnnunciatorAlert(data.alert);
                }
            } catch (e) {
                console.log('Poll error:', e);
            }
        }

        function showAnnunciatorAlert(alert) {
            console.log('showAnnunciatorAlert called:', alert.message);

            // Play tone
            playAlertTone();

            // Show floating alert
            const alertEl = document.getElementById('annunciatorAlert');
            const msgEl = document.getElementById('annunciatorMessage');
            console.log('Alert element:', alertEl, 'Message element:', msgEl);
            msgEl.textContent = alert.message;
            alertEl.classList.add('show');
            console.log('Alert classes after show:', alertEl.className);

            // Speak the message
            speakAnnunciator(alert.message);

            // Auto-dismiss after 5 seconds
            if (annunciatorAlertTimeout) {
                clearTimeout(annunciatorAlertTimeout);
            }
            annunciatorAlertTimeout = setTimeout(() => {
                dismissAnnunciatorAlert();
            }, 5000);

            // Log it
            addLogEntry('ANN: ' + alert.message, 'zibo');
        }

        function dismissAnnunciatorAlert() {
            const alertEl = document.getElementById('annunciatorAlert');
            alertEl.classList.remove('show');
            if (annunciatorAlertTimeout) {
                clearTimeout(annunciatorAlertTimeout);
                annunciatorAlertTimeout = null;
            }
        }

        function playAlertTone() {
            // Create a simple beep using Web Audio API
            try {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);

                oscillator.frequency.value = 880; // A5 note
                oscillator.type = 'sine';
                gainNode.gain.value = 0.3;

                oscillator.start();
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                oscillator.stop(audioCtx.currentTime + 0.3);
            } catch (e) {
                console.log('Could not play alert tone:', e);
            }
        }

        function speakAnnunciator(text) {
            if (!window.speechSynthesis) return;

            // Cancel any current speech
            speechSynthesis.cancel();

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = 1.0;
            utterance.pitch = 1.0;
            utterance.volume = 1.0;
            speechSynthesis.speak(utterance);
        }

        function addLogEntry(msg, cls) {
            const log = document.getElementById('logPanel');
            const entry = document.createElement('div');
            entry.className = 'entry ' + (cls || '');
            entry.textContent = msg;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        // Initialize annunciators after a delay to ensure connection is established
        setTimeout(initAnnunciators, 2000);

        // Poll annunciator alerts alongside checklist polling
        setInterval(pollAnnunciatorAlert, 500);

        // Periodically check annunciator status
        setInterval(checkAnnunciatorStatus, 5000);
    </script>
</body>
</html>
